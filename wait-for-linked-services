#!/bin/bash
#
# Given standard docker line variables, parses and waits for them to respond to SYNs in parallel with timeout.
# Works with tcp, udp, and unix sockets.
#
# @deps bash>=4 netcat
# @url https://github.com/akatrevorjay/wait-for-linked-services
# @author trevorj
#
set -eo pipefail

: ${TIMEOUT:=30}

#
# Output
#

SELF="$(basename "$0")"

function _script_echo   { echo "[$(date)] $0[$$]" "${@:2}" "#$1"; }
function debug          { [[ -z "$DEBUG" ]] || _script_echo DEBUG "$@"; }
function e              { [[ -n "$QUIET" ]] || _script_echo INFO "$@"; }
function info           { e "$@"; }
function warn           { [[ -n "$QUIET" ]] || _script_echo WARNING "$@"; }
function warning        { warn "$@"; }
function error          { _script_echo ERROR "$@" >&2; }
function death          { error "$@"; exit 1; }
function debug_call     { debug 'call:' "$@"; "$@"; }

#
# Net utils
#

function is_netaddr {
    [[ "$1" = *:* ]]
}

function split_netaddr {
    local host="${1%:*}" port="${1#*:}"
    echo "$host" "$port"
}

function split_url_proto {
    echo "${1%%://*}" "${1#*://}"
}

#
# Link variable parsing
#

function get_service_urls {
    local name="${1^^}" var=''
    # This ugly thing looks for $name_$NUM_PORT_$PORT_$PROTO variables
    for var in $(compgen -A variable | egrep "^${name}_PORT_[0-9]+_[A-Z]+$"); do
        echo "${!var}"
    done
}

function get_service_primary_url {
    local name="${1^^}"
    local var="${name}_PORT"
    echo "${!var}"
}

function get_all_services_urls {
    get_service_urls "[A-Z0-9]+_[0-9]+"
}

function get_all_services_names {
    local var='' name=''
    for var in $(compgen -A variable | egrep '^[A-Z0-9_]+_NAME$'); do
        name="${var%_NAME}"
        echo "$name"
    done
}

#
# Checks
#

function is_url_port_open {
    local url="$1"
    debug "Checking if $url is open"

    set -- $(split_url_proto "$url")
    local proto="$1" addr="$2"

    [[ -n "$proto" ]] || error "No proto found for service $name"
    [[ -n "$addr" ]] || error "No addr found for service $name"

    local nc="nc -z"
    case "$proto" in
        unix)
            $nc -U "$addr" ;;
        udp)
            nc+=" -u" ;;&
        tcp)
            local host="${addr%%:*}" port="${url##*:}"
            [[ -n "$host" ]] || death "No host found for service $name"
            [[ -n "$port" ]] || death "No port found for service $name"
            $nc "$host" "$port" ;;
        *)
            warn "Unknown proto $proto. Ignoring."
            return ;;
    esac
}

#
# Instance loop
#

function wait_for_url_port_open {
    local url="$1" timeout_secs="${2:-$TIMEOUT}"
    debug "Checking service url: $url (timeout=${timeout_secs}s)"

    local i=0
    while [ $i -lt $timeout_secs ]
    do
        if is_url_port_open "$url"; then
            return 0
        fi
        let i++ || :
        sleep 1
    done

    error "Timed out waiting for service: $name"
    return 1
}

#
# Main
#

function main {
    # make sure we have `nc`
    type nc > /dev/null || death "failed to find 'nc'"

    local service='' url='' services=''
    if [[ -n "$__SERVICE_INNER" ]]; then
        services="$__SERVICE_NAMES"
        url="$__SERVICE_URL"
        debug "URL: $url for $services"
        wait_for_url_port_open "$url"
        return 0
    fi

    if [[ -z "$*" ]]; then
        # If none were specified, check all linked services
        debug "Getting a list of all linked services"
        set -- $(get_all_services_names)
    fi

    # Check again
    if [[ -z "$*" ]]; then
        debug "No linked services found."
        return 0
    fi

    debug "Waiting for services: $*"

    # Collect a mapping of service urls to their services
    # (deduplicates urls, common practice to have multiple names for the same, eg compose)
    local -A urls
    for service in "$@"; do
        url=$(get_service_primary_url "$service")
        if [[ -z "$url" ]]; then
            error "No URLs found for service: $service"
            continue
        fi
        urls["$url"]+="$service "
    done

    local -a pids
    for url in "${!urls[@]}"; do
        services="${urls["$url"]}"
        __SERVICE_INNER=yes __SERVICE_NAMES="$services" __SERVICE_URL="$url" "$0" &
        pids+=("$!")
    done

    for pid in "${pids[@]}"; do
        debug "Waiting on pid $pid"
        wait "$pid"
    done
    debug "Waiting for any remaining pids"
    wait

    debug "Done"
}

main "$@"
